"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("effect"),u=require("node:sqlite"),g=require("fastify"),h=require("@fastify/cors"),z={INTERNAL_SERVER_ERROR:500},M="SELECT * FROM mazes WHERE maze_id = ?",R="SELECT * FROM mazes",N="SELECT maze_id, mazeName, description, created_at FROM mazes",A="INSERT INTO mazes (maze_id, mazeName, description, created_at ,numCols, numRows, grid) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING maze_id, created_at",_="DELETE FROM mazes WHERE maze_id = ?",v=`
CREATE TABLE IF NOT EXISTS mazes (
	maze_id TEXT PRIMARY KEY,
	mazeName TEXT NOT NULL,
	description TEXT NOT NULL,
	numCols INTEGER NOT NULL,
	numRows INTEGER NOT NULL,
	grid ARRAY NOT NULL,
	created_at TEXT NOT NULL
);`,y="/maze/:maze_id",L="/maze/metadata";e.Config.integer("PORT").pipe(e.Config.withDefault(8081));e.Config.string("HOST").pipe(e.Config.withDefault("localhost"));const D=e.Schema.Boolean,f=e.Schema.Array(D),O=e.Schema.Struct({vertical:f,horizontal:f}),l=e.Schema.Struct({maze_id:e.Schema.String,mazeName:e.Schema.String,description:e.Schema.String,created_at:e.Schema.String}),P=e.Schema.Array(l),o=e.Schema.Struct({...l.fields,numCols:e.Schema.Number,numRows:e.Schema.Number,grid:e.Schema.Array(O)}),I=o.omit("grid").pipe(e.Schema.extend(e.Schema.Struct({grid:e.Schema.String}))),p=e.Schema.transform(I,o,{encode:t=>({...t,grid:JSON.stringify(t.grid)}),decode:t=>({...t,grid:JSON.parse(t.grid)})}),C=e.Schema.Array(p),E=e.Schema.Struct({x:e.Schema.Number,y:e.Schema.Number});e.Schema.Struct({maze:o,currentPosition:E,playerMoves:E});e.Schema.Struct({dx:e.Schema.Number,dy:e.Schema.Number,currentX:e.Schema.Number,currentY:e.Schema.Number,maze:o});e.Schema.Struct({maze:o,player:e.Schema.String,gameMode:e.Schema.String});const d=t=>{const c=new u.DatabaseSync(t);return{get:(a,r)=>e.Effect.tryPromise({try:()=>Promise.resolve(c.prepare(a).get(...r)),catch:s=>s}),all:a=>e.Effect.tryPromise({try:()=>Promise.resolve(c.prepare(a).all()),catch:r=>r}),run:(a,r)=>e.Effect.tryPromise({try:()=>Promise.resolve(c.prepare(a).run(...r??[])),catch:s=>s})}},i=e.Effect.Service()("DatabaseService",{effect:e.Effect.succeed(d("data.sqlite"))}),b=e.Layer.succeed(i,d(":memory:")),T=t=>({initMazeSchema:e.pipe(t.run(v),e.Effect.map(()=>t)),insertMaze:c=>e.pipe(t.run(A,Object.values(c)),e.Effect.catchTag("DatabaseError",a=>e.Effect.fail(a))),getMazeById:c=>e.pipe(t.get(M,[c]),e.Effect.map(a=>e.Schema.decodeUnknownSync(p)(a)),e.Effect.catchTag("DatabaseError",a=>e.Effect.fail(a))),getMetadata:e.pipe(t.all(N),e.Effect.map(c=>e.Schema.decodeUnknownSync(P)(c)),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c))),getAllMazes:e.pipe(t.all(R),e.Effect.map(c=>e.Schema.decodeUnknownSync(C)(c)),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c))),deleteMaze:c=>e.pipe(t.run(_,[c]),e.Effect.catchTag("DatabaseError",a=>e.Effect.fail(a)))}),n=e.Effect.Service()("MazeDBService",{dependencies:[i.Default],effect:i.pipe(e.Effect.map(T))});e.Effect.Service()("MazeDBService",{dependencies:[b],effect:i.pipe(e.Effect.map(T))});const U=t=>e.pipe(e.Effect.sync(()=>{t.get("/",async(c,a)=>{a.send([{Hell:"Maze",age:99}])}),t.get(y,async(c,a)=>{const{maze_id:r}=c.params;return m.getMaze(r).then(s=>{a.send(s)}).catch(s=>{console.error("Error fetching maze:",s),a.status(500).send({error:"Failed to fetch maze"})})}),t.get(L,async(c,a)=>m.getAllMazes().then(r=>{a.send(r)}).catch(()=>{a.status(z.INTERNAL_SERVER_ERROR).send({status:"error",error:"Failed to fetch all mazes"})}))}),e.Effect.map(()=>t)),m={getMaze:t=>e.pipe(n,e.Effect.flatMap(c=>c.getMazeById(t)),e.Effect.provide(n.Default),e.Effect.runPromise),getAllMazes:()=>e.pipe(n,e.Effect.flatMap(t=>t.getAllMazes),e.Effect.provide(n.Default),e.Effect.runPromise)},G=()=>{const t=g();return t.register(h,{origin:"*"}),{start:()=>e.Effect.async(c=>{const a=Number(process.env.PORT||"3000");t.listen({host:"0.0.0.0",port:a},(r,s)=>{r&&(console.error("Server error:",r),process.exit(1)),console.log(`Server listening on ${s}`)})}),register:c=>e.pipe(t,c,e.Effect.tap(()=>e.Effect.log("Routes registered successfully"))),process:()=>{e.Effect.sync(()=>{process.on("SIGINT",()=>{console.log("SIGINT signal received: closing HTTP server"),t.close(()=>{console.log("HTTP server closed"),process.exit(0)})}),process.on("SIGTERM",()=>{console.log("SIGTERM signal received: closing HTTP server"),t.close(()=>{console.log("HTTP server closed"),process.exit(0)})})})},server:()=>t}},S=e.Effect.Service()("HTTPServer",{effect:e.Effect.succeed(G())}),H=async()=>S.pipe(e.Effect.tap(t=>t.register(U)),e.Effect.tap(t=>t.process()),e.Effect.tap(t=>t.start()),e.Effect.provide(S.Default),e.Effect.runPromise),w=H();exports.viteNodeApp=w;
