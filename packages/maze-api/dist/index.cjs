"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("effect"),M=require("node:sqlite"),L=require("node:fs"),N=require("node:path"),_=require("@fastify/cors"),P=require("fastify");function d(t){const a=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(t){for(const c in t)if(c!=="default"){const r=Object.getOwnPropertyDescriptor(t,c);Object.defineProperty(a,c,r.get?r:{enumerable:!0,get:()=>t[c]})}}return a.default=t,Object.freeze(a)}const D=d(L),i=d(N),m={INTERNAL_SERVER_ERROR:500},z="SELECT * FROM mazes WHERE maze_id = ?",v="SELECT * FROM mazes",I="SELECT maze_id, mazeName, description, created_at FROM mazes",O="INSERT INTO mazes (maze_id, mazeName, description, created_at ,numCols, numRows, grid) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING maze_id, created_at",C="DELETE FROM mazes WHERE maze_id = ?",b=`
CREATE TABLE IF NOT EXISTS mazes (
	maze_id TEXT PRIMARY KEY,
	mazeName TEXT NOT NULL,
	description TEXT NOT NULL,
	numCols INTEGER NOT NULL,
	numRows INTEGER NOT NULL,
	grid ARRAY NOT NULL,
	created_at TEXT NOT NULL
);`,U=`
CREATE TABLE IF NOT EXISTS players (
	playerID TEXT PRIMARY KEY,
	name TEXT NOT NULL,
	value TEXT NOT NULL,
	description TEXT NOT NULL
);`,w="INSERT INTO players (playerID, name, value, description ) VALUES (?, ?, ?, ?) RETURNING playerID, name, value, description",B="SELECT * FROM players WHERE playerID = ?",F="SELECT * FROM players",G="DELETE FROM players WHERE playerID = ?",Y="/player/:playerID",H="/player",X="/maze/:maze_id",j="/maze",k="/maze/metadata";e.Config.integer("PORT").pipe(e.Config.withDefault(8081));e.Config.string("HOST").pipe(e.Config.withDefault("localhost"));const q=e.Schema.Boolean,p=e.Schema.Array(q),x=e.Schema.Struct({vertical:p,horizontal:p}),g=e.Schema.Struct({maze_id:e.Schema.String,mazeName:e.Schema.String,description:e.Schema.String,created_at:e.Schema.String}),Z=e.Schema.Array(g),f=e.Schema.Struct({...g.fields,numCols:e.Schema.Number,numRows:e.Schema.Number,grid:e.Schema.Array(x)}),V=f.omit("grid").pipe(e.Schema.extend(e.Schema.Struct({grid:e.Schema.String}))),h=e.Schema.transform(V,f,{encode:t=>({...t,grid:JSON.stringify(t.grid)}),decode:t=>({...t,grid:JSON.parse(t.grid)})}),W=e.Schema.Array(h),S=e.Schema.Struct({x:e.Schema.Number,y:e.Schema.Number});e.Schema.Struct({maze:f,currentPosition:S,playerMoves:S});e.Schema.Struct({dx:e.Schema.Number,dy:e.Schema.Number,currentX:e.Schema.Number,currentY:e.Schema.Number,maze:f});e.Schema.Struct({maze:f,player:e.Schema.String,gameMode:e.Schema.String});const R=e.Schema.Struct({playerID:e.Schema.String,name:e.Schema.String,value:e.Schema.String,description:e.Schema.String}),$=e.Schema.Array(R),J=(t=process.cwd())=>{let a=t;for(;a!==i.parse(a).root;){const c=i.join(a,"README.md");if(D.existsSync(c))return a;a=i.dirname(a)}throw new Error("Moonrepo root not found. Make sure moon.yml exists.")},K=J(),y=t=>{const a=new M.DatabaseSync(t);return{get:(c,r)=>e.Effect.tryPromise({try:()=>Promise.resolve(a.prepare(c).get(...r)),catch:s=>s}),all:c=>e.Effect.tryPromise({try:()=>Promise.resolve(a.prepare(c).all()),catch:r=>r}),run:(c,r)=>e.Effect.tryPromise({try:()=>Promise.resolve(a.prepare(c).run(...r??[])),catch:s=>s})}},n=e.Effect.Service()("DatabaseService",{effect:e.Effect.succeed(y(`${K}/data.sqlite`))}),Q=e.Layer.succeed(n,y(":memory:")),A=t=>({initMazeSchema:e.pipe(t.run(b),e.Effect.map(()=>t)),insertMaze:a=>e.pipe(t.run(O,Object.values(a)),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c))),getMazeById:a=>e.pipe(t.get(z,[a]),e.Effect.map(c=>e.Schema.decodeUnknownSync(h)(c)),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c))),getMetadata:e.pipe(t.all(I),e.Effect.map(a=>e.Schema.decodeUnknownSync(Z)(a)),e.Effect.catchTag("DatabaseError",a=>e.Effect.fail(a))),getAllMazes:e.pipe(t.all(v),e.Effect.map(a=>e.Schema.decodeUnknownSync(W)(a)),e.Effect.catchTag("DatabaseError",a=>e.Effect.fail(a))),deleteMaze:a=>e.pipe(t.run(C,[a]),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c)))}),o=e.Effect.Service()("MazeDBService",{dependencies:[n.Default],effect:n.pipe(e.Effect.map(A))});e.Effect.Service()("MazeDBService",{dependencies:[Q],effect:n.pipe(e.Effect.map(A))});const ee=t=>({initPlayereSchema:e.pipe(t.run(U),e.Effect.map(()=>t)),insertPlayer:a=>e.pipe(t.run(w,Object.values(a)),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c))),getPlayerById:a=>e.pipe(t.get(B,[a]),e.Effect.map(c=>e.Schema.decodeUnknownSync(R)(c)),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c))),getAllPlayers:e.pipe(t.all(F),e.Effect.map(a=>e.Schema.decodeUnknownSync($)(a)),e.Effect.catchTag("DatabaseError",a=>e.Effect.fail(a))),deletePlayer:a=>e.pipe(t.run(G,[a]),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c)))}),E=e.Effect.Service()("PlayerDBService",{dependencies:[n.Default],effect:n.pipe(e.Effect.map(ee))}),te=t=>e.pipe(e.Effect.sync(()=>{t.get("/",async(a,c)=>{c.send([{Hell:"Maze",age:99}])}),t.get(X,async(a,c)=>{const{maze_id:r}=a.params;return l.getMaze(r).then(s=>{c.send(s)}).catch(s=>{console.error("Error fetching maze:",s),c.status(500).send({error:"Failed to fetch maze"})})}),t.get(k,async(a,c)=>l.getAllMetaData().then(r=>{c.send(r)}).catch(()=>{c.status(m.INTERNAL_SERVER_ERROR).send({status:"error",error:"Failed to fetch maze metada"})})),t.get(j,async(a,c)=>l.getAllMazes().then(r=>{c.send(r)}).catch(()=>{c.status(m.INTERNAL_SERVER_ERROR).send({status:"error",error:"Failed to fetch all mazes"})}))}),e.Effect.map(()=>t)),l={getMaze:t=>e.pipe(o,e.Effect.flatMap(a=>a.getMazeById(t)),e.Effect.provide(o.Default),e.Effect.runPromise),getAllMetaData:()=>e.pipe(o,e.Effect.flatMap(t=>t.getMetadata),e.Effect.provide(o.Default),e.Effect.runPromise),getAllMazes:()=>e.pipe(o,e.Effect.flatMap(t=>t.getAllMazes),e.Effect.provide(o.Default),e.Effect.runPromise)},ae=t=>e.pipe(e.Effect.sync(()=>{t.get(Y,async(a,c)=>{const{playerID:r}=a.params;return u.getPlayer(r).then(s=>{c.send(s)}).catch(s=>{console.error("Error fetching maze:",s),c.status(500).send({error:"Failed to fetch player"})})}),t.get(H,async(a,c)=>u.getAllPlayers().then(r=>{c.send(r)}).catch(()=>{c.status(m.INTERNAL_SERVER_ERROR).send({status:"error",error:"Failed to fetch all players"})}))}),e.Effect.map(()=>t)),u={getPlayer:t=>e.pipe(E,e.Effect.flatMap(a=>a.getPlayerById(t)),e.Effect.provide(E.Default),e.Effect.runPromise),getAllPlayers:()=>e.pipe(E,e.Effect.flatMap(t=>t.getAllPlayers),e.Effect.provide(E.Default),e.Effect.runPromise)},ce=()=>{const t=P();return t.register(_,{origin:"*"}),{start:()=>e.Effect.async(a=>{const c=Number(process.env.PORT||"3000");t.listen({host:"0.0.0.0",port:c},(r,s)=>{r&&(console.error("Server error:",r),process.exit(1)),console.log(`Server listening on ${s}`)})}),register:a=>e.pipe(t,a,e.Effect.tap(()=>e.Effect.log("Routes registered successfully"))),process:()=>{e.Effect.sync(()=>{process.on("SIGINT",()=>{console.log("SIGINT signal received: closing HTTP server"),t.close(()=>{console.log("HTTP server closed"),process.exit(0)})}),process.on("SIGTERM",()=>{console.log("SIGTERM signal received: closing HTTP server"),t.close(()=>{console.log("HTTP server closed"),process.exit(0)})})})},server:()=>t}},T=e.Effect.Service()("HTTPServer",{effect:e.Effect.succeed(ce())}),re=async()=>T.pipe(e.Effect.tap(t=>t.register(te)),e.Effect.tap(t=>t.register(ae)),e.Effect.tap(t=>t.process()),e.Effect.tap(t=>t.start()),e.Effect.provide(T.Default),e.Effect.runPromise),se=re();exports.viteNodeApp=se;
