"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("effect"),y=require("node:sqlite"),A=require("@fastify/cors"),L=require("fastify"),l={INTERNAL_SERVER_ERROR:500},N="SELECT * FROM mazes WHERE maze_id = ?",M="SELECT * FROM mazes",_="SELECT maze_id, mazeName, description, created_at FROM mazes",z="INSERT INTO mazes (maze_id, mazeName, description, created_at ,numCols, numRows, grid) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING maze_id, created_at",P="DELETE FROM mazes WHERE maze_id = ?",D=`
CREATE TABLE IF NOT EXISTS mazes (
	maze_id TEXT PRIMARY KEY,
	mazeName TEXT NOT NULL,
	description TEXT NOT NULL,
	numCols INTEGER NOT NULL,
	numRows INTEGER NOT NULL,
	grid ARRAY NOT NULL,
	created_at TEXT NOT NULL
);`,v=`
CREATE TABLE IF NOT EXISTS players (
	playerID TEXT PRIMARY KEY,
	name TEXT NOT NULL,
	value TEXT NOT NULL,
	description TEXT NOT NULL
);`,I="INSERT INTO players (playerID, name, value, description ) VALUES (?, ?, ?, ?) RETURNING playerID, name, value, description",O="SELECT * FROM players WHERE playerID = ?",C="SELECT * FROM players",U="DELETE FROM players WHERE playerID = ?",b="/player/:playerID",B="/player",F="/maze/:maze_id",G="/maze",Y="/maze/metadata";e.Config.integer("PORT").pipe(e.Config.withDefault(8081));e.Config.string("HOST").pipe(e.Config.withDefault("localhost"));const H=e.Schema.Boolean,m=e.Schema.Array(H),w=e.Schema.Struct({vertical:m,horizontal:m}),d=e.Schema.Struct({maze_id:e.Schema.String,mazeName:e.Schema.String,description:e.Schema.String,created_at:e.Schema.String}),X=e.Schema.Array(d),E=e.Schema.Struct({...d.fields,numCols:e.Schema.Number,numRows:e.Schema.Number,grid:e.Schema.Array(w)}),Z=E.omit("grid").pipe(e.Schema.extend(e.Schema.Struct({grid:e.Schema.String}))),u=e.Schema.transform(Z,E,{encode:t=>({...t,grid:JSON.stringify(t.grid)}),decode:t=>({...t,grid:JSON.parse(t.grid)})}),k=e.Schema.Array(u),S=e.Schema.Struct({x:e.Schema.Number,y:e.Schema.Number});e.Schema.Struct({maze:E,currentPosition:S,playerMoves:S});e.Schema.Struct({dx:e.Schema.Number,dy:e.Schema.Number,currentX:e.Schema.Number,currentY:e.Schema.Number,maze:E});e.Schema.Struct({maze:E,player:e.Schema.String,gameMode:e.Schema.String});const g=e.Schema.Struct({playerID:e.Schema.String,name:e.Schema.String,value:e.Schema.String,description:e.Schema.String}),q=e.Schema.Array(g),h=t=>{const a=new y.DatabaseSync(t);return{get:(c,r)=>e.Effect.tryPromise({try:()=>Promise.resolve(a.prepare(c).get(...r)),catch:s=>s}),all:c=>e.Effect.tryPromise({try:()=>Promise.resolve(a.prepare(c).all()),catch:r=>r}),run:(c,r)=>e.Effect.tryPromise({try:()=>Promise.resolve(a.prepare(c).run(...r??[])),catch:s=>s})}},o=e.Effect.Service()("DatabaseService",{effect:e.Effect.succeed(h("data.sqlite"))}),x=e.Layer.succeed(o,h(":memory:")),R=t=>({initMazeSchema:e.pipe(t.run(D),e.Effect.map(()=>t)),insertMaze:a=>e.pipe(t.run(z,Object.values(a)),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c))),getMazeById:a=>e.pipe(t.get(N,[a]),e.Effect.map(c=>e.Schema.decodeUnknownSync(u)(c)),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c))),getMetadata:e.pipe(t.all(_),e.Effect.map(a=>e.Schema.decodeUnknownSync(X)(a)),e.Effect.catchTag("DatabaseError",a=>e.Effect.fail(a))),getAllMazes:e.pipe(t.all(M),e.Effect.map(a=>e.Schema.decodeUnknownSync(k)(a)),e.Effect.catchTag("DatabaseError",a=>e.Effect.fail(a))),deleteMaze:a=>e.pipe(t.run(P,[a]),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c)))}),n=e.Effect.Service()("MazeDBService",{dependencies:[o.Default],effect:o.pipe(e.Effect.map(R))});e.Effect.Service()("MazeDBService",{dependencies:[x],effect:o.pipe(e.Effect.map(R))});const V=t=>({initPlayereSchema:e.pipe(t.run(v),e.Effect.map(()=>t)),insertPlayer:a=>e.pipe(t.run(I,Object.values(a)),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c))),getPlayerById:a=>e.pipe(t.get(O,[a]),e.Effect.map(c=>e.Schema.decodeUnknownSync(g)(c)),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c))),getAllPlayers:e.pipe(t.all(C),e.Effect.map(a=>e.Schema.decodeUnknownSync(q)(a)),e.Effect.catchTag("DatabaseError",a=>e.Effect.fail(a))),deletePlayer:a=>e.pipe(t.run(U,[a]),e.Effect.catchTag("DatabaseError",c=>e.Effect.fail(c)))}),f=e.Effect.Service()("PlayerDBService",{dependencies:[o.Default],effect:o.pipe(e.Effect.map(V))}),W=t=>e.pipe(e.Effect.sync(()=>{t.get("/",async(a,c)=>{c.send([{Hell:"Maze",age:99}])}),t.get(F,async(a,c)=>{const{maze_id:r}=a.params;return i.getMaze(r).then(s=>{c.send(s)}).catch(s=>{console.error("Error fetching maze:",s),c.status(500).send({error:"Failed to fetch maze"})})}),t.get(Y,async(a,c)=>i.getAllMetaData().then(r=>{c.send(r)}).catch(()=>{c.status(l.INTERNAL_SERVER_ERROR).send({status:"error",error:"Failed to fetch maze metada"})})),t.get(G,async(a,c)=>i.getAllMazes().then(r=>{c.send(r)}).catch(()=>{c.status(l.INTERNAL_SERVER_ERROR).send({status:"error",error:"Failed to fetch all mazes"})}))}),e.Effect.map(()=>t)),i={getMaze:t=>e.pipe(n,e.Effect.flatMap(a=>a.getMazeById(t)),e.Effect.provide(n.Default),e.Effect.runPromise),getAllMetaData:()=>e.pipe(n,e.Effect.flatMap(t=>t.getMetadata),e.Effect.provide(n.Default),e.Effect.runPromise),getAllMazes:()=>e.pipe(n,e.Effect.flatMap(t=>t.getAllMazes),e.Effect.provide(n.Default),e.Effect.runPromise)},j=t=>e.pipe(e.Effect.sync(()=>{t.get(b,async(a,c)=>{const{playerID:r}=a.params;return p.getPlayer(r).then(s=>{c.send(s)}).catch(s=>{console.error("Error fetching maze:",s),c.status(500).send({error:"Failed to fetch player"})})}),t.get(B,async(a,c)=>p.getAllPlayers().then(r=>{c.send(r)}).catch(()=>{c.status(l.INTERNAL_SERVER_ERROR).send({status:"error",error:"Failed to fetch all players"})}))}),e.Effect.map(()=>t)),p={getPlayer:t=>e.pipe(f,e.Effect.flatMap(a=>a.getPlayerById(t)),e.Effect.provide(f.Default),e.Effect.runPromise),getAllPlayers:()=>e.pipe(f,e.Effect.flatMap(t=>t.getAllPlayers),e.Effect.provide(f.Default),e.Effect.runPromise)},J=()=>{const t=L();return t.register(A,{origin:"*"}),{start:()=>e.Effect.async(a=>{const c=Number(process.env.PORT||"8080");t.listen({host:"0.0.0.0",port:c},(r,s)=>{r&&(console.error("Server error:",r),process.exit(1)),console.log(`Server listening on ${s}`)})}),register:a=>e.pipe(t,a,e.Effect.tap(()=>e.Effect.log("Routes registered successfully"))),process:()=>{e.Effect.sync(()=>{process.on("SIGINT",()=>{console.log("SIGINT signal received: closing HTTP server"),t.close(()=>{console.log("HTTP server closed"),process.exit(0)})}),process.on("SIGTERM",()=>{console.log("SIGTERM signal received: closing HTTP server"),t.close(()=>{console.log("HTTP server closed"),process.exit(0)})})})},server:()=>t}},T=e.Effect.Service()("HTTPServer",{effect:e.Effect.succeed(J())}),K=async()=>T.pipe(e.Effect.tap(t=>t.register(W)),e.Effect.tap(t=>t.register(j)),e.Effect.tap(t=>t.process()),e.Effect.tap(t=>t.start()),e.Effect.provide(T.Default),e.Effect.runPromise),$=K();exports.viteNodeApp=$;
