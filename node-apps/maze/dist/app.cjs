"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("effect"),k=require("node:readline"),$=require("node:readline/promises"),d=require("@inquirer/prompts"),i=require("@effect/platform");class E extends e.Context.Tag("CurrentPositionState")(){}class o extends e.Context.Tag("MazeDataState")(){}const N=`http://${process.env.HOST}:${Number(process.env.PORT||"8080")}`,m={right:{x:0,y:1},down:{x:1,y:0},left:{x:0,y:-1},up:{x:-1,y:0}},P={player:"",maze:{maze_id:"",mazeName:"",description:"",created_at:"0",numCols:0,numRows:0,grid:[{vertical:[!1,!1,!1,!1,!1],horizontal:[!1,!1,!1,!1,!1]}]},gameMode:""};$.createInterface({input:process.stdin,output:process.stdout});const _=()=>{process.stdout.write("\x1B[H\x1B[2J\x1B[3J")},G={buildTopWall:e.pipe(o,e.Effect.flatMap(c=>e.Ref.get(c)),e.Effect.map(c=>{const t=c.maze.numCols;return`${Array.from({length:t*2+1},(a,f)=>f===1?"    ":f%2===0?"+":"----").join("")}\r
`})),buildVerticalRow:(c,t,a)=>e.pipe(e.Effect.succeed(c),e.Effect.map(f=>{let r=[];return f.forEach((s,l)=>{r=[...r,l===t?` ${a} `:"    "],r=[...r,s?" ":"|"]}),r})),buildHorizRow:c=>e.pipe(e.Effect.succeed(c),e.Effect.map(t=>{let a=[];return a=[...a,`\r
+`],t.forEach((f,r)=>{a=[...a,f?"    ":"----"],a=[...a,"+"]}),a=[...a,`\r
`],a}))};class p extends e.Context.Tag("BuilderMaze")(){static Live=p.of(G)}class n{constructor(t){this.message=t}_tag="GamePlayError"}const W="/player",O="/maze/:maze_id",H="/maze",Y="/maze/metadata";e.Config.integer("PORT").pipe(e.Config.withDefault(8081));e.Config.string("HOST").pipe(e.Config.withDefault("localhost"));const q=e.Schema.Boolean,v=e.Schema.Array(q),X=e.Schema.Struct({vertical:v,horizontal:v}),w=e.Schema.Struct({maze_id:e.Schema.String,mazeName:e.Schema.String,description:e.Schema.String,created_at:e.Schema.String}),b=e.Schema.Array(w),u=e.Schema.Struct({...w.fields,numCols:e.Schema.Number,numRows:e.Schema.Number,grid:e.Schema.Array(X)}),B=u.omit("grid").pipe(e.Schema.extend(e.Schema.Struct({grid:e.Schema.String}))),J=e.Schema.transform(B,u,{encode:c=>({...c,grid:JSON.stringify(c.grid)}),decode:c=>({...c,grid:JSON.parse(c.grid)})});e.Schema.Array(J);const R=e.Schema.Struct({x:e.Schema.Number,y:e.Schema.Number});e.Schema.Struct({maze:u,currentPosition:R,playerMoves:R});const F=e.Schema.Struct({dx:e.Schema.Number,dy:e.Schema.Number,currentX:e.Schema.Number,currentY:e.Schema.Number,maze:u}),I=e.Schema.Struct({maze:u,player:e.Schema.String,gameMode:e.Schema.String}),U=e.Schema.Struct({playerID:e.Schema.String,name:e.Schema.String,value:e.Schema.String,description:e.Schema.String}),j=e.Schema.Array(U),V=[{vertical:[!0,!0,!1,!0,!1],horizontal:[!0,!1,!0,!0,!0]},{vertical:[!0,!1,!1,!1,!1],horizontal:[!1,!1,!0,!0,!0]},{vertical:[!0,!0,!1,!1,!1],horizontal:[!0,!1,!1,!1,!0]},{vertical:[!1,!0,!0,!0,!1],horizontal:[!0,!1,!0,!1,!0]},{vertical:[!0,!0,!1,!0,!1],horizontal:[!1,!1,!1,!1,!0]}],Z={maze_id:"001",mazeName:"Level 1: The Labyrinths",description:"This is a 5x5 maze",created_at:new Date().toISOString(),numCols:5,numRows:5,grid:V},K=({x:c,y:t,maze:{numCols:a,grid:f}},r)=>e.pipe(e.Effect.succeed(t<a-1&&f[c].vertical[t]&&!r.has(`${c},${t+1}`)),e.Effect.flatMap(s=>s?e.Effect.succeed({x:c,y:t+1,path:[m.right]}):e.Effect.succeed(void 0))),Q=({x:c,y:t,maze:{numRows:a,grid:f}},r)=>e.pipe(e.Effect.succeed(c<a-1&&f[c].horizontal[t]&&!r.has(`${c+1},${t}`)),e.Effect.flatMap(s=>s?e.Effect.succeed({x:c+1,y:t,path:[m.down]}):e.Effect.succeed(void 0))),ee=({x:c,y:t,maze:{grid:a}},f)=>e.pipe(e.Effect.succeed(t>0&&a[c].vertical[t-1]&&!f.has(`${c},${t-1}`)),e.Effect.flatMap(r=>r?e.Effect.succeed({x:c,y:t-1,path:[m.left]}):e.Effect.succeed(void 0))),te=({x:c,y:t,maze:{grid:a}},f)=>e.pipe(e.Effect.succeed(c>0&&a[c-1].horizontal[t]&&!f.has(`${c-1},${t}`)),e.Effect.flatMap(r=>r?e.Effect.succeed({x:c-1,y:t,path:[m.up]}):e.Effect.succeed(void 0))),ce=(c,t)=>e.pipe(e.Effect.all([K(c,t),Q(c,t),ee(c,t),te(c,t)]),e.Effect.flatMap(a=>{const f=a.filter(r=>r!==void 0);return a.length>0?e.Effect.succeed(f):e.Effect.fail(new n("No valid moves available"))})),ae=(c,t,a)=>e.pipe(e.Effect.succeed(a.pop()),e.Effect.flatMap(f=>{if(!f)return e.Effect.succeed([]);const{x:r,y:s,path:l}=f;if(r===t.numRows-1&&s===t.numCols-1)return e.Effect.succeed(l);const M=`${r},${s}`;return c.has(M)?e.Effect.succeed([]):(c.add(M),e.pipe(ce({x:r,y:s,maze:t},c),e.Effect.map(L=>{L.forEach(h=>{a.push({x:h.x,y:h.y,path:[...l,...h.path]})})})))})),fe=c=>e.Effect.loop({stack:[{x:0,y:0,path:[{x:0,y:0}]}],visited:new Set,maze:c},{while:({stack:t})=>t.length>0,step:t=>t,body:t=>ae(t.visited,t.maze,t.stack)}),x=c=>fe(c).pipe(e.Effect.flatMap(t=>{const a=t.find(f=>f!==void 0)||[];return e.Effect.succeed(a)}));x(Z).pipe(e.Effect.flatMap(c=>(console.log("Solved Maze Path:",c),e.Effect.succeed(c))),e.Effect.runPromise);const re=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("newX",t=>e.Effect.succeed(t.dx+t.currentX)),e.Effect.bind("newY",t=>e.Effect.succeed(t.dy+t.currentY)),e.Effect.bind("condition",({newX:t,newY:a})=>e.Effect.succeed(t<0||a<0||t>=c.maze.numRows||a>=c.maze.numCols)),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new n("Out of bounds")):e.Effect.succeed(!1))),se=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===0&&t.dy===1&&t.currentY<t.maze.numCols-1&&!t.maze.grid[t.currentX].vertical[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new n("Wall to the right")):e.Effect.succeed(!1))),oe=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===1&&t.dy===0&&t.currentX<t.maze.numRows-1&&!t.maze.grid[t.currentX].horizontal[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new n("Wall below")):e.Effect.succeed(!1))),ie=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===0&&t.dy===-1&&t.currentY>0&&!t.maze.grid[t.currentX].vertical[t.currentY-1])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new n("Wall to the left")):e.Effect.succeed(!1))),ne=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===-1&&t.dy===0&&t.currentX>0&&!t.maze.grid[t.currentX-1].horizontal[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new n("Wall above")):e.Effect.succeed(!1))),le=c=>e.pipe(e.Effect.succeed(c),e.Effect.map(t=>({dx:t.playerMoves.x,dy:t.playerMoves.y,currentX:t.currentPosition.x,currentY:t.currentPosition.y,maze:t.maze})),e.Effect.map(t=>e.Schema.decodeUnknownSync(F)(t))),pe=c=>e.pipe(le(c),e.Effect.flatMap(t=>re(t).pipe(e.Effect.andThen(()=>ne(t)),e.Effect.andThen(()=>oe(t)),e.Effect.andThen(()=>ie(t)),e.Effect.andThen(()=>se(t)))),e.Effect.flatMap(()=>e.Effect.succeed({x:c.currentPosition.x+c.playerMoves.x,y:c.currentPosition.y+c.playerMoves.y})),e.Effect.catchTag("GamePlayError",t=>e.Effect.fail(t))),ue=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("position",()=>e.Ref.get(c.currentPosition)),e.Effect.bind("mazeState",()=>e.Ref.get(c.maze)),e.Effect.map(({position:t,mazeState:{maze:a}})=>t.x===a.numRows-1&&t.y===a.numCols-1?e.Effect.succeed("Game Over"):e.Effect.fail(new n("Game not over"))),e.Effect.flatMap(t=>t),e.Effect.catchTag("GamePlayError",t=>e.Effect.succeed(t))),Ee=(c,t)=>e.pipe(e.Effect.succeed(c),e.Effect.bindTo("gameState"),e.Effect.bind("state",({gameState:a})=>(console.log(`Moving player to position: (${t.x}, ${t.y})`),e.Effect.succeed({playerMoves:t,...a}))),e.Effect.tap(({state:a})=>T(a)),e.Effect.flatMap(({state:a})=>ue(a))),de=c=>e.pipe(e.Ref.get(c.maze),e.Effect.flatMap(({maze:t})=>x(t).pipe(e.Effect.flatMap(a=>e.Effect.forEach(a,f=>Ee(c,f).pipe(e.Effect.delay("500 millis"))))))),C=e.Effect.map(i.HttpClient.HttpClient,c=>c.pipe(i.HttpClient.mapRequest(e.flow(i.HttpClientRequest.acceptJson,i.HttpClientRequest.prependUrl(N))))),A=(c,t)=>e.Effect.succeed(i.HttpClientResponse.matchStatus({200:a=>i.HttpClientResponse.schemaBodyJson(t)(a),orElse:a=>e.Effect.fail(a)})(c)).pipe(e.Effect.flatMap(a=>a)),S=(c,t)=>e.pipe(C,e.Effect.flatMap(a=>a.get(c)),e.Effect.flatMap(a=>A(a,t)),e.Effect.provide(i.FetchHttpClient.layer)),me=(c,t,a)=>e.pipe(C,e.Effect.flatMap(f=>f.get(Object.entries(t).reduce((r,[s,l])=>r.replace(`:${s}`,l),c))),e.Effect.flatMap(f=>A(f,a)),e.Effect.provide(i.FetchHttpClient.layer)),he={getDataMaze:()=>S(Y,b),getMaze:c=>me(O,{maze_id:c},u),getAllMazes:()=>S(H,b),getAllPlayers:()=>S(W,j)},y=e.Effect.Service()("MazeAPIService",{dependencies:[],effect:e.Effect.succeed(he)}),Se=c=>e.Effect.promise(()=>d.select({message:"Choose your labyrinth tier:",choices:c.map(t=>({name:t.mazeName,value:t.maze_id,description:t.description}))})).pipe(e.Effect.map(t=>t)),ge=c=>e.Effect.promise(()=>d.select({message:"Select your player character:",choices:c})).pipe(e.Effect.map(t=>t)),ye=e.pipe(e.Effect.promise(()=>d.select({message:"Pick your gameplay mode:",choices:["Freedom","Guided"]})),e.Effect.map(c=>c)),ze=y.pipe(e.Effect.map(c=>c.getAllPlayers()),e.Effect.flatMap(c=>c.pipe(e.Effect.flatMap(t=>ge(t))))),Me=y.pipe(e.Effect.map(c=>({maze:c.getDataMaze(),mazeAPI:c})),e.Effect.flatMap(({maze:c,mazeAPI:t})=>c.pipe(e.Effect.flatMap(a=>Se(a)),e.Effect.flatMap(a=>t.getMaze(a))))),ve=e.pipe(e.Effect.promise(()=>d.select({message:"Do you want to play again?",choices:["Yes","No"]})),e.Effect.map(c=>c));class g extends e.Effect.Service()("Maze",{dependencies:[y.Default],effect:e.pipe(e.Effect.all({clear:e.Effect.sync(()=>console.clear()),player:ze,maze:Me,gameMode:ye}),e.Effect.map(({player:t,maze:a,gameMode:f})=>e.Schema.decodeUnknownSync(I)({player:t,maze:a,gameMode:f})),e.Effect.tap(t=>e.pipe(o,e.Effect.flatMap(a=>e.Ref.set(a,t)))))}){}e.Layer.mergeAll(g.Default,e.Layer.effect(o,e.Ref.make(P)));const be=({x:c,y:t},a)=>c===a?t:-1,Re=({vertical:c,horizontal:t},a)=>e.pipe(e.Effect.all({builderMaze:p,currentPosition:E,mazeData:o}),e.Effect.bind("position",({currentPosition:f})=>e.Ref.get(f)),e.Effect.bind("maze",({mazeData:f})=>e.Ref.get(f)),e.Effect.flatMap(({builderMaze:f,position:r,maze:s})=>e.Effect.all({verticalRow:f.buildVerticalRow(c,be(r,a),s.player),horizontalRow:f.buildHorizRow(t)})),e.Effect.map(({verticalRow:f,horizontalRow:r})=>["|",...f,...r])),Pe=e.pipe(e.Effect.all({mazeData:o,builder:p}),e.Effect.bind("state",({mazeData:c})=>e.Ref.get(c)),e.Effect.bind("topWall",({builder:c})=>c.buildTopWall),e.Effect.bind("mazeLayout",({state:{maze:c}})=>e.pipe(c.grid,e.Effect.forEach(Re),e.Effect.map(t=>t.flat()))),e.Effect.map(({topWall:c,mazeLayout:t})=>[...c,...t]),e.Effect.provideService(p,p.Live)),T=({currentPosition:c,maze:t,playerMoves:a})=>e.pipe(e.Effect.all({currPostion:e.Ref.get(c),mazeVal:e.Ref.get(t)}),e.Effect.flatMap(({currPostion:f,mazeVal:r})=>pe({currentPosition:f,maze:r.maze,playerMoves:a})),e.Effect.tap(f=>e.pipe(e.Ref.update(c,()=>f),e.Effect.zip(D({currentPosition:c,maze:t})),e.Effect.zip(xe({currentPosition:c,maze:t})))),e.Effect.catchTag("GamePlayError",e.Effect.succeed),e.Effect.runPromise),we=()=>ve.pipe(e.Effect.map(c=>{c==="Yes"?z.pipe(e.Effect.runPromise):(console.log("Thank you for playing! Goodbye!"),process.exit())})),xe=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("position",()=>e.Ref.get(c.currentPosition)),e.Effect.bind("mazeState",()=>e.Ref.get(c.maze)),e.Effect.tap(({position:t,mazeState:{maze:a}})=>{t.x===a.numRows-1&&t.y===a.numCols-1&&(console.log("Congratulations 🎉 🎉 🎉! You have reached the end of the maze."),process.stdin.removeAllListeners("keypress"),e.Effect.runPromiseExit(we()))})),Ce=c=>e.pipe(e.Effect.sync(()=>{k.emitKeypressEvents(process.stdin),process.stdin.setRawMode(!0),process.stdin.resume(),process.stdin.setMaxListeners(100)}),e.Effect.flatMap(()=>e.Effect.async(()=>{process.stdin.on("keypress",(t,a)=>{let f={x:0,y:0};if(t==="")process.exit();else{switch(a.name){case"up":f={x:-1,y:0};break;case"down":f={x:1,y:0};break;case"left":f={x:0,y:-1};break;case"right":f={x:0,y:1};break}console.log(`Player Moves: ${JSON.stringify(f)}`),T({playerMoves:f,...c})}})}))),D=c=>e.pipe(Pe,e.Effect.tap(()=>_()),e.Effect.tap(t=>console.log(t.join(""))),e.Effect.provideServiceEffect(o,e.Effect.succeed(c.maze)),e.Effect.provideServiceEffect(E,e.Effect.succeed(c.currentPosition))),Ae=e.pipe(e.Effect.all({maze:o,currentPosition:E}),e.Effect.flatMap(({maze:c,currentPosition:t})=>e.pipe(e.Ref.get(c),e.Effect.flatMap(a=>a.gameMode==="Freedom"?de({maze:c,currentPosition:t}):Ce({maze:c,currentPosition:t}))))),Te=e.pipe(e.Effect.all({maze:o,currentPosition:E}),e.Effect.tap(({currentPosition:c,maze:t})=>D({maze:t,currentPosition:c})),e.Effect.tap(()=>Ae),e.Effect.provideServiceEffect(E,e.Ref.make({x:0,y:0}))),z=g.pipe(e.Effect.flatMap(()=>Te),e.Effect.provide(g.Default),e.Effect.provideServiceEffect(o,e.Ref.make(P)));e.Effect.runPromise(z);exports.mazeApp=z;
