"use strict";const e=require("effect"),w=require("node:readline"),A=require("node:readline/promises"),S=require("@inquirer/prompts"),i=require("@effect/platform");class o{constructor(t){this.message=t}_tag="GamePlayError"}const T="/player",D="/maze/:maze_id",G="/maze",L="/maze/metadata",H=e.Config.integer("PORT").pipe(e.Config.withDefault(8081)),O=e.Config.string("HOST").pipe(e.Config.withDefault("localhost")),_=e.Schema.Boolean,g=e.Schema.Array(_),N=e.Schema.Struct({vertical:g,horizontal:g}),b=e.Schema.Struct({maze_id:e.Schema.String,mazeName:e.Schema.String,description:e.Schema.String,created_at:e.Schema.String}),y=e.Schema.Array(b),p=e.Schema.Struct({...b.fields,numCols:e.Schema.Number,numRows:e.Schema.Number,grid:e.Schema.Array(N)}),k=p.omit("grid").pipe(e.Schema.extend(e.Schema.Struct({grid:e.Schema.String}))),W=e.Schema.transform(k,p,{encode:c=>({...c,grid:JSON.stringify(c.grid)}),decode:c=>({...c,grid:JSON.parse(c.grid)})});e.Schema.Array(W);const M=e.Schema.Struct({x:e.Schema.Number,y:e.Schema.Number});e.Schema.Struct({maze:p,currentPosition:M,playerMoves:M});const Y=e.Schema.Struct({dx:e.Schema.Number,dy:e.Schema.Number,currentX:e.Schema.Number,currentY:e.Schema.Number,maze:p}),q=e.Schema.Struct({maze:p,player:e.Schema.String,gameMode:e.Schema.String}),X=e.Schema.Struct({playerID:e.Schema.String,name:e.Schema.String,value:e.Schema.String,description:e.Schema.String}),B=e.Schema.Array(X);class d extends e.Context.Tag("CurrentPositionState")(){}class n extends e.Context.Tag("MazeDataState")(){}e.Effect.gen(function*(c){const t=yield*c(O),a=yield*c(H);return`http://${t}:${a}`});const $=`http://${process.env.HOST}:${Number(process.env.PORT||"8080")}`,z=[{x:0,y:1},{x:1,y:0},{x:0,y:-1},{x:-1,y:0}],v={player:"",maze:{maze_id:"",mazeName:"",description:"",created_at:"0",numCols:0,numRows:0,grid:[{vertical:[!1,!1,!1,!1,!1],horizontal:[!1,!1,!1,!1,!1]}]},gameMode:""};A.createInterface({input:process.stdin,output:process.stdout});const J=()=>{process.stdout.write("\x1B[H\x1B[2J\x1B[3J")},F={buildTopWall:e.pipe(n,e.Effect.flatMap(c=>e.Ref.get(c)),e.Effect.map(c=>{const t=c.maze.numCols;return`${Array.from({length:t*2+1},(a,f)=>f===1?"    ":f%2===0?"+":"----").join("")}\r
`})),buildVerticalRow:(c,t,a)=>e.pipe(e.Effect.succeed(c),e.Effect.map(f=>{let r=[];return f.forEach((l,E)=>{r=[...r,E===t?` ${a} `:"    "],r=[...r,l?" ":"|"]}),r})),buildHorizRow:c=>e.pipe(e.Effect.succeed(c),e.Effect.map(t=>{let a=[];return a=[...a,`\r
+`],t.forEach((f,r)=>{a=[...a,f?"    ":"----"],a=[...a,"+"]}),a=[...a,`\r
`],a}))};class s extends e.Context.Tag("BuilderMaze")(){static Live=s.of(F)}const I=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("newX",t=>e.Effect.succeed(t.dx+t.currentX)),e.Effect.bind("newY",t=>e.Effect.succeed(t.dy+t.currentY)),e.Effect.bind("condition",({newX:t,newY:a})=>e.Effect.succeed(t<0||a<0||t>=c.maze.numRows||a>=c.maze.numCols)),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new o("Out of bounds")):e.Effect.succeed(!1))),U=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===0&&t.dy===1&&t.currentY<t.maze.numCols-1&&!t.maze.grid[t.currentX].vertical[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new o("Wall to the right")):e.Effect.succeed(!1))),j=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===1&&t.dy===0&&t.currentX<t.maze.numRows-1&&!t.maze.grid[t.currentX].horizontal[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new o("Wall below")):e.Effect.succeed(!1))),V=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===0&&t.dy===-1&&t.currentY>0&&!t.maze.grid[t.currentX].vertical[t.currentY-1])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new o("Wall to the left")):e.Effect.succeed(!1))),Z=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===-1&&t.dy===0&&t.currentX>0&&!t.maze.grid[t.currentX-1].horizontal[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new o("Wall above")):e.Effect.succeed(!1))),K=c=>e.pipe(e.Effect.succeed(c),e.Effect.map(t=>({dx:t.playerMoves.x,dy:t.playerMoves.y,currentX:t.currentPosition.x,currentY:t.currentPosition.y,maze:t.maze})),e.Effect.map(t=>e.Schema.decodeUnknownSync(Y)(t))),Q=c=>e.pipe(K(c),e.Effect.flatMap(t=>I(t).pipe(e.Effect.andThen(()=>Z(t)),e.Effect.andThen(()=>j(t)),e.Effect.andThen(()=>V(t)),e.Effect.andThen(()=>U(t)))),e.Effect.flatMap(()=>e.Effect.succeed({x:c.currentPosition.x+c.playerMoves.x,y:c.currentPosition.y+c.playerMoves.y})),e.Effect.catchTag("GamePlayError",t=>e.Effect.fail(t))),ee=c=>e.Effect.sync(()=>e.pipe(e.Effect.succeed(c),e.Effect.bindTo("gameState"),e.Effect.bind("randomDirection",()=>e.Effect.succeed(z[Math.floor(Math.random()*z.length)])),e.Effect.bind("state",({randomDirection:t,gameState:a})=>e.Effect.succeed({playerMoves:t,...a})),e.Effect.tap(({state:t})=>R(t)),e.Effect.flatMap(({state:t})=>te(t)))),te=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("position",()=>e.Ref.get(c.currentPosition)),e.Effect.bind("mazeState",()=>e.Ref.get(c.maze)),e.Effect.map(({position:t,mazeState:{maze:a}})=>t.x===a.numRows-1&&t.y===a.numCols-1?e.Effect.succeed("Game Over"):e.Effect.fail(new o("Game not over"))),e.Effect.flatMap(t=>t),e.Effect.catchTag("GamePlayError",t=>e.Effect.succeed(t))),ce=c=>e.Effect.repeat(ee(c),{until:t=>t.pipe(e.Effect.map(a=>a==="Game Over")),schedule:e.Schedule.addDelay(e.Schedule.forever,()=>"50 millis")}),ae=({x:c,y:t},a)=>c===a?t:-1,fe=({vertical:c,horizontal:t},a)=>e.pipe(e.Effect.all({builderMaze:s,currentPosition:d,mazeData:n}),e.Effect.bind("position",({currentPosition:f})=>e.Ref.get(f)),e.Effect.bind("maze",({mazeData:f})=>e.Ref.get(f)),e.Effect.flatMap(({builderMaze:f,position:r,maze:l})=>e.Effect.all({verticalRow:f.buildVerticalRow(c,ae(r,a),l.player),horizontalRow:f.buildHorizRow(t)})),e.Effect.map(({verticalRow:f,horizontalRow:r})=>["|",...f,...r])),re=e.pipe(e.Effect.all({mazeData:n,builder:s}),e.Effect.bind("state",({mazeData:c})=>e.Ref.get(c)),e.Effect.bind("topWall",({builder:c})=>c.buildTopWall),e.Effect.bind("mazeLayout",({state:{maze:c}})=>e.pipe(c.grid,e.Effect.forEach(fe),e.Effect.map(t=>t.flat()))),e.Effect.map(({topWall:c,mazeLayout:t})=>[...c,...t]),e.Effect.provideService(s,s.Live)),R=({currentPosition:c,maze:t,playerMoves:a})=>e.pipe(e.Effect.all({currPostion:e.Ref.get(c),mazeVal:e.Ref.get(t)}),e.Effect.flatMap(({currPostion:f,mazeVal:r})=>Q({currentPosition:f,maze:r.maze,playerMoves:a})),e.Effect.tap(f=>e.pipe(e.Ref.update(c,()=>f),e.Effect.zip(P({currentPosition:c,maze:t})),e.Effect.zip(ne({currentPosition:c,maze:t})))),e.Effect.catchTag("GamePlayError",e.Effect.succeed),e.Effect.runPromise),ne=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("position",()=>e.Ref.get(c.currentPosition)),e.Effect.bind("mazeState",()=>e.Ref.get(c.maze)),e.Effect.tap(({position:t,mazeState:{maze:a}})=>{t.x===a.numRows-1&&t.y===a.numCols-1&&(console.log("Congratulations ðŸŽ‰ ðŸŽ‰ ðŸŽ‰! You have reached the end of the maze."),process.exit())})),ie=c=>e.pipe(e.Effect.sync(()=>{w.emitKeypressEvents(process.stdin),process.stdin.setRawMode(!0),process.stdin.resume()}),e.Effect.flatMap(()=>e.Effect.async(()=>{process.stdin.on("keypress",(t,a)=>{let f={x:0,y:0};if(t==="")process.exit();else{switch(a.name){case"up":f={x:-1,y:0};break;case"down":f={x:1,y:0};break;case"left":f={x:0,y:-1};break;case"right":f={x:0,y:1};break}R({playerMoves:f,...c})}})}))),P=c=>e.pipe(re,e.Effect.tap(()=>J()),e.Effect.tap(t=>console.log(t.join(""))),e.Effect.provideServiceEffect(n,e.Effect.succeed(c.maze)),e.Effect.provideServiceEffect(d,e.Effect.succeed(c.currentPosition))),se=e.pipe(e.Effect.all({maze:n,currentPosition:d}),e.Effect.flatMap(({maze:c,currentPosition:t})=>e.pipe(e.Ref.get(c),e.Effect.flatMap(a=>a.gameMode==="Freedom"?ce({maze:c,currentPosition:t}):ie({maze:c,currentPosition:t}))))),oe=e.pipe(e.Effect.all({maze:n,currentPosition:d}),e.Effect.tap(({currentPosition:c,maze:t})=>P({maze:t,currentPosition:c})),e.Effect.tap(()=>se),e.Effect.provideServiceEffect(d,e.Ref.make({x:0,y:0}))),x=e.Effect.map(i.HttpClient.HttpClient,c=>c.pipe(i.HttpClient.mapRequest(e.flow(i.HttpClientRequest.acceptJson,i.HttpClientRequest.prependUrl($))))),C=(c,t)=>e.Effect.succeed(i.HttpClientResponse.matchStatus({200:a=>i.HttpClientResponse.schemaBodyJson(t)(a),orElse:a=>e.Effect.fail(a)})(c)).pipe(e.Effect.flatMap(a=>a)),u=(c,t)=>e.pipe(x,e.Effect.flatMap(a=>a.get(c)),e.Effect.flatMap(a=>C(a,t)),e.Effect.provide(i.FetchHttpClient.layer)),pe=(c,t,a)=>e.pipe(x,e.Effect.flatMap(f=>f.get(Object.entries(t).reduce((r,[l,E])=>r.replace(`:${l}`,E),c))),e.Effect.flatMap(f=>C(f,a)),e.Effect.provide(i.FetchHttpClient.layer)),le={getDataMaze:()=>u(L,y),getMaze:c=>pe(D,{maze_id:c},p),getAllMazes:()=>u(G,y),getAllPlayers:()=>u(T,B)},h=e.Effect.Service()("MazeAPIService",{dependencies:[],effect:e.Effect.succeed(le)}),de=c=>e.Effect.promise(()=>S.select({message:"Choose your labyrinth tier:",choices:c.map(t=>({name:t.mazeName,value:t.maze_id,description:t.description}))})).pipe(e.Effect.map(t=>t)),Ee=c=>e.Effect.promise(()=>S.select({message:"Select your player character:",choices:c})).pipe(e.Effect.map(t=>t)),ue=e.pipe(e.Effect.promise(()=>S.select({message:"Pick your gameplay mode:",choices:["Freedom","Guided"]})),e.Effect.map(c=>c)),me=h.pipe(e.Effect.map(c=>c.getAllPlayers()),e.Effect.flatMap(c=>c.pipe(e.Effect.flatMap(t=>Ee(t))))),Se=h.pipe(e.Effect.map(c=>({maze:c.getDataMaze(),mazeAPI:c})),e.Effect.flatMap(({maze:c,mazeAPI:t})=>c.pipe(e.Effect.flatMap(a=>de(a)),e.Effect.flatMap(a=>t.getMaze(a)))));class m extends e.Effect.Service()("Maze",{dependencies:[h.Default],effect:e.pipe(e.Effect.all({player:me,maze:Se,gameMode:ue}),e.Effect.map(({player:t,maze:a,gameMode:f})=>e.Schema.decodeUnknownSync(q)({player:t,maze:a,gameMode:f})),e.Effect.tap(t=>e.pipe(n,e.Effect.flatMap(a=>e.Ref.set(a,t)))))}){}e.Layer.mergeAll(m.Default,e.Layer.effect(n,e.Ref.make(v)));e.pipe(m,e.Effect.flatMap(()=>oe),e.Effect.provide(m.Default),e.Effect.provideServiceEffect(n,e.Ref.make(v)),e.Effect.runPromise);
