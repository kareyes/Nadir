"use strict";const e=require("effect"),x=require("node:readline"),w=require("node:readline/promises"),E=require("@inquirer/prompts"),i=require("@effect/platform");class s{constructor(t){this.message=t}_tag="GamePlayError"}const P="/maze/:maze_id",C="/maze/metadata",T=e.Config.integer("PORT").pipe(e.Config.withDefault(8081)),A=e.Config.string("HOST").pipe(e.Config.withDefault("localhost")),H=e.Schema.Boolean,m=e.Schema.Array(H),k=e.Schema.Struct({vertical:m,horizontal:m}),y=e.Schema.Struct({maze_id:e.Schema.String,mazeName:e.Schema.String,description:e.Schema.String,created_at:e.Schema.String}),D=e.Schema.Array(y),l=e.Schema.Struct({...y.fields,numCols:e.Schema.Number,numRows:e.Schema.Number,grid:e.Schema.Array(k)}),G=l.omit("grid").pipe(e.Schema.extend(e.Schema.Struct({grid:e.Schema.String}))),O=e.Schema.transform(G,l,{encode:c=>({...c,grid:JSON.stringify(c.grid)}),decode:c=>({...c,grid:JSON.parse(c.grid)})});e.Schema.Array(O);const h=e.Schema.Struct({x:e.Schema.Number,y:e.Schema.Number});e.Schema.Struct({maze:l,currentPosition:h,playerMoves:h});const N=e.Schema.Struct({dx:e.Schema.Number,dy:e.Schema.Number,currentX:e.Schema.Number,currentY:e.Schema.Number,maze:l}),q=e.Schema.Struct({maze:l,player:e.Schema.String,gameMode:e.Schema.String});class d extends e.Context.Tag("CurrentPositionState")(){}class n extends e.Context.Tag("MazeDataState")(){}e.Effect.gen(function*(c){const t=yield*c(A),a=yield*c(T);return`http://${t}:${a}`});const W=`http://${process.env.HOST}:${Number(process.env.PORT||"8080")}`,S=[{x:0,y:1},{x:1,y:0},{x:0,y:-1},{x:-1,y:0}],_={player:"",maze:{maze_id:"",mazeName:"",description:"",created_at:"0",numCols:0,numRows:0,grid:[{vertical:[!1,!1,!1,!1,!1],horizontal:[!1,!1,!1,!1,!1]}]},gameMode:""},L=[{name:"🐶 - Brian Griffin",value:"🐶",description:"Has average agility, often displaying quick reflexes in comedic situations but not particularly athletic."},{name:"🐱 - Pusheen",value:"🐱",description:"A cute, chubby cat with limited agility, often depicted as more playful and relaxed than physically nimble."},{name:"🐭 - Jerry",value:"🐭",description:"Jerry is highly agile, swiftly outmaneuvering Tom with quick reflexes and clever tricks."},{name:"🐼 - Pan-Pan",value:"🐼",description:"Playful and energetic character with surprising agility, often darting around with quick movements."},{name:"🐰 - Snowball",value:"🐰",description:"Snowball is incredibly agile, darting swiftly and gracefully to evade attacks and outmaneuver opponents."}];w.createInterface({input:process.stdin,output:process.stdout});const Y=()=>{process.stdout.write("\x1B[H\x1B[2J\x1B[3J")},B={buildTopWall:e.pipe(n,e.Effect.flatMap(c=>e.Ref.get(c)),e.Effect.map(c=>{const t=c.maze.numCols;return`${Array.from({length:t*2+1},(a,f)=>f===1?"    ":f%2===0?"+":"----").join("")}\r
`})),buildVerticalRow:(c,t,a)=>e.pipe(e.Effect.succeed(c),e.Effect.map(f=>{let r=[];return f.forEach((p,u)=>{r=[...r,u===t?` ${a} `:"    "],r=[...r,p?" ":"|"]}),r})),buildHorizRow:c=>e.pipe(e.Effect.succeed(c),e.Effect.map(t=>{let a=[];return a=[...a,`\r
+`],t.forEach((f,r)=>{a=[...a,f?"    ":"----"],a=[...a,"+"]}),a=[...a,`\r
`],a}))};class o extends e.Context.Tag("BuilderMaze")(){static Live=o.of(B)}const X=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("newX",t=>e.Effect.succeed(t.dx+t.currentX)),e.Effect.bind("newY",t=>e.Effect.succeed(t.dy+t.currentY)),e.Effect.bind("condition",({newX:t,newY:a})=>e.Effect.succeed(t<0||a<0||t>=c.maze.numRows||a>=c.maze.numCols)),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new s("Out of bounds")):e.Effect.succeed(!1))),J=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===0&&t.dy===1&&t.currentY<t.maze.numCols-1&&!t.maze.grid[t.currentX].vertical[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new s("Wall to the right")):e.Effect.succeed(!1))),$=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===1&&t.dy===0&&t.currentX<t.maze.numRows-1&&!t.maze.grid[t.currentX].horizontal[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new s("Wall below")):e.Effect.succeed(!1))),F=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===0&&t.dy===-1&&t.currentY>0&&!t.maze.grid[t.currentX].vertical[t.currentY-1])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new s("Wall to the left")):e.Effect.succeed(!1))),I=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===-1&&t.dy===0&&t.currentX>0&&!t.maze.grid[t.currentX-1].horizontal[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new s("Wall above")):e.Effect.succeed(!1))),U=c=>e.pipe(e.Effect.succeed(c),e.Effect.map(t=>({dx:t.playerMoves.x,dy:t.playerMoves.y,currentX:t.currentPosition.x,currentY:t.currentPosition.y,maze:t.maze})),e.Effect.map(t=>e.Schema.decodeUnknownSync(N)(t))),j=c=>e.pipe(U(c),e.Effect.flatMap(t=>X(t).pipe(e.Effect.andThen(()=>I(t)),e.Effect.andThen(()=>$(t)),e.Effect.andThen(()=>F(t)),e.Effect.andThen(()=>J(t)))),e.Effect.flatMap(()=>e.Effect.succeed({x:c.currentPosition.x+c.playerMoves.x,y:c.currentPosition.y+c.playerMoves.y})),e.Effect.catchTag("GamePlayError",t=>e.Effect.fail(t))),V=c=>e.Effect.sync(()=>e.pipe(e.Effect.succeed(c),e.Effect.bindTo("gameState"),e.Effect.bind("randomDirection",()=>e.Effect.succeed(S[Math.floor(Math.random()*S.length)])),e.Effect.bind("state",({randomDirection:t,gameState:a})=>e.Effect.succeed({playerMoves:t,...a})),e.Effect.tap(({state:t})=>M(t)),e.Effect.flatMap(({state:t})=>Z(t)))),Z=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("position",()=>e.Ref.get(c.currentPosition)),e.Effect.bind("mazeState",()=>e.Ref.get(c.maze)),e.Effect.map(({position:t,mazeState:{maze:a}})=>t.x===a.numRows-1&&t.y===a.numCols-1?e.Effect.succeed("Game Over"):e.Effect.fail(new s("Game not over"))),e.Effect.flatMap(t=>t),e.Effect.catchTag("GamePlayError",t=>e.Effect.succeed(t))),K=c=>e.Effect.repeat(V(c),{until:t=>t.pipe(e.Effect.map(a=>a==="Game Over")),schedule:e.Schedule.addDelay(e.Schedule.forever,()=>"50 millis")}),Q=({x:c,y:t},a)=>c===a?t:-1,ee=({vertical:c,horizontal:t},a)=>e.pipe(e.Effect.all({builderMaze:o,currentPosition:d,mazeData:n}),e.Effect.bind("position",({currentPosition:f})=>e.Ref.get(f)),e.Effect.bind("maze",({mazeData:f})=>e.Ref.get(f)),e.Effect.flatMap(({builderMaze:f,position:r,maze:p})=>e.Effect.all({verticalRow:f.buildVerticalRow(c,Q(r,a),p.player),horizontalRow:f.buildHorizRow(t)})),e.Effect.map(({verticalRow:f,horizontalRow:r})=>["|",...f,...r])),te=e.pipe(e.Effect.all({mazeData:n,builder:o}),e.Effect.bind("state",({mazeData:c})=>e.Ref.get(c)),e.Effect.bind("topWall",({builder:c})=>c.buildTopWall),e.Effect.bind("mazeLayout",({state:{maze:c}})=>e.pipe(c.grid,e.Effect.forEach(ee),e.Effect.map(t=>t.flat()))),e.Effect.map(({topWall:c,mazeLayout:t})=>[...c,...t]),e.Effect.provideService(o,o.Live)),M=({currentPosition:c,maze:t,playerMoves:a})=>e.pipe(e.Effect.all({currPostion:e.Ref.get(c),mazeVal:e.Ref.get(t)}),e.Effect.flatMap(({currPostion:f,mazeVal:r})=>j({currentPosition:f,maze:r.maze,playerMoves:a})),e.Effect.tap(f=>e.pipe(e.Ref.update(c,()=>f),e.Effect.zip(z({currentPosition:c,maze:t})),e.Effect.zip(ce({currentPosition:c,maze:t})))),e.Effect.catchTag("GamePlayError",e.Effect.succeed),e.Effect.runPromise),ce=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("position",()=>e.Ref.get(c.currentPosition)),e.Effect.bind("mazeState",()=>e.Ref.get(c.maze)),e.Effect.tap(({position:t,mazeState:{maze:a}})=>{t.x===a.numRows-1&&t.y===a.numCols-1&&(console.log("Congratulations 🎉 🎉 🎉! You have reached the end of the maze."),process.exit())})),ae=c=>e.pipe(e.Effect.sync(()=>{x.emitKeypressEvents(process.stdin),process.stdin.setRawMode(!0),process.stdin.resume()}),e.Effect.flatMap(()=>e.Effect.async(()=>{process.stdin.on("keypress",(t,a)=>{let f={x:0,y:0};if(t==="")process.exit();else{switch(a.name){case"up":f={x:-1,y:0};break;case"down":f={x:1,y:0};break;case"left":f={x:0,y:-1};break;case"right":f={x:0,y:1};break}M({playerMoves:f,...c})}})}))),z=c=>e.pipe(te,e.Effect.tap(()=>Y()),e.Effect.tap(t=>console.log(t.join(""))),e.Effect.provideServiceEffect(n,e.Effect.succeed(c.maze)),e.Effect.provideServiceEffect(d,e.Effect.succeed(c.currentPosition))),fe=e.pipe(e.Effect.all({maze:n,currentPosition:d}),e.Effect.flatMap(({maze:c,currentPosition:t})=>e.pipe(e.Ref.get(c),e.Effect.flatMap(a=>a.gameMode==="Freedom"?K({maze:c,currentPosition:t}):ae({maze:c,currentPosition:t}))))),re=e.pipe(e.Effect.all({maze:n,currentPosition:d}),e.Effect.tap(({currentPosition:c,maze:t})=>z({maze:t,currentPosition:c})),e.Effect.tap(()=>fe),e.Effect.provideServiceEffect(d,e.Ref.make({x:0,y:0}))),b=e.Effect.map(i.HttpClient.HttpClient,c=>c.pipe(i.HttpClient.mapRequest(e.flow(i.HttpClientRequest.acceptJson,i.HttpClientRequest.prependUrl(W))))),v=(c,t)=>e.Effect.succeed(i.HttpClientResponse.matchStatus({200:a=>i.HttpClientResponse.schemaBodyJson(t)(a),orElse:a=>e.Effect.fail(a)})(c)).pipe(e.Effect.flatMap(a=>a)),ie=(c,t)=>e.pipe(b,e.Effect.flatMap(a=>a.get(c)),e.Effect.flatMap(a=>v(a,t)),e.Effect.provide(i.FetchHttpClient.layer)),ne=(c,t,a)=>e.pipe(b,e.Effect.flatMap(f=>f.get(Object.entries(t).reduce((r,[p,u])=>r.replace(`:${p}`,u),c))),e.Effect.flatMap(f=>v(f,a)),e.Effect.provide(i.FetchHttpClient.layer)),oe={getDataMaze:()=>ie(C,D),getMaze:c=>ne(P,{maze_id:c},l)},R=e.Effect.Service()("MazeAPIService",{dependencies:[],effect:e.Effect.succeed(oe)}),se=c=>e.Effect.promise(()=>E.select({message:"Choose your labyrinth tier:",choices:c.map(t=>({name:t.mazeName,value:t.maze_id,description:t.description}))})).pipe(e.Effect.map(t=>t)),le=e.pipe(e.Effect.promise(()=>E.select({message:"Select your player character:",choices:L})),e.Effect.map(c=>c)),pe=e.pipe(e.Effect.promise(()=>E.select({message:"Pick your gameplay mode:",choices:["Freedom","Guided"]})),e.Effect.map(c=>c)),de=R.pipe(e.Effect.map(c=>({maze:c.getDataMaze(),mazeAPI:c})),e.Effect.flatMap(({maze:c,mazeAPI:t})=>c.pipe(e.Effect.flatMap(a=>se(a)),e.Effect.flatMap(a=>t.getMaze(a)))));class g extends e.Effect.Service()("Maze",{dependencies:[R.Default],effect:e.pipe(e.Effect.all({player:le,maze:de,gameMode:pe}),e.Effect.map(({player:t,maze:a,gameMode:f})=>e.Schema.decodeUnknownSync(q)({player:t,maze:a,gameMode:f})),e.Effect.tap(t=>e.Effect.gen(function*(){const a=yield*n;yield*e.Ref.set(a,t)})))}){}e.pipe(g,e.Effect.flatMap(()=>re),e.Effect.provide(g.Default),e.Effect.provideServiceEffect(n,e.Ref.make(_)),e.Effect.runPromise);
