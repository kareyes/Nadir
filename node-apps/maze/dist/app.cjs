"use strict";const e=require("effect"),x=require("node:readline"),P=require("node:readline/promises"),E=require("@inquirer/prompts"),i=require("@effect/platform");class s{constructor(t){this.message=t}_tag="GamePlayError"}const w="/maze/:maze_id",C="/maze/metadata",T=e.Config.integer("PORT").pipe(e.Config.withDefault(8081)),A=e.Config.string("HOST").pipe(e.Config.withDefault("localhost")),D=e.Schema.Boolean,m=e.Schema.Array(D),k=e.Schema.Struct({vertical:m,horizontal:m}),M=e.Schema.Struct({maze_id:e.Schema.String,mazeName:e.Schema.String,description:e.Schema.String,created_at:e.Schema.String}),H=e.Schema.Array(M),l=e.Schema.Struct({...M.fields,numCols:e.Schema.Number,numRows:e.Schema.Number,grid:e.Schema.Array(k)}),G=l.omit("grid").pipe(e.Schema.extend(e.Schema.Struct({grid:e.Schema.String}))),N=e.Schema.transform(G,l,{encode:c=>({...c,grid:JSON.stringify(c.grid)}),decode:c=>({...c,grid:JSON.parse(c.grid)})});e.Schema.Array(N);const h=e.Schema.Struct({x:e.Schema.Number,y:e.Schema.Number});e.Schema.Struct({maze:l,currentPosition:h,playerMoves:h});const O=e.Schema.Struct({dx:e.Schema.Number,dy:e.Schema.Number,currentX:e.Schema.Number,currentY:e.Schema.Number,maze:l}),_=e.Schema.Struct({maze:l,player:e.Schema.String,gameMode:e.Schema.String});class d extends e.Context.Tag("CurrentPositionState")(){}class r extends e.Context.Tag("MazeDataState")(){}const B=e.Effect.gen(function*(c){const t=yield*c(A),a=yield*c(T);return`http://${t}:${a}`}),q=`http://${process.env.HOST}:${Number(process.env.PORT||"8080")}`,y=[{x:0,y:1},{x:1,y:0},{x:0,y:-1},{x:-1,y:0}],L={player:"",maze:{maze_id:"",mazeName:"",description:"",created_at:"0",numCols:0,numRows:0,grid:[{vertical:[!1,!1,!1,!1,!1],horizontal:[!1,!1,!1,!1,!1]}]},gameMode:""},W=[{name:"🐶 - Brian Griffin",value:"🐶",description:"Has average agility, often displaying quick reflexes in comedic situations but not particularly athletic."},{name:"🐱 - Pusheen",value:"🐱",description:"A cute, chubby cat with limited agility, often depicted as more playful and relaxed than physically nimble."},{name:"🐭 - Jerry",value:"🐭",description:"Jerry is highly agile, swiftly outmaneuvering Tom with quick reflexes and clever tricks."},{name:"🐼 - Pan-Pan",value:"🐼",description:"Playful and energetic character with surprising agility, often darting around with quick movements."},{name:"🐰 - Snowball",value:"🐰",description:"Snowball is incredibly agile, darting swiftly and gracefully to evade attacks and outmaneuver opponents."}];P.createInterface({input:process.stdin,output:process.stdout});const Y=()=>{process.stdout.write("\x1B[H\x1B[2J\x1B[3J")},I={buildTopWall:e.pipe(r,e.Effect.flatMap(c=>e.Ref.get(c)),e.Effect.map(c=>{const t=c.maze.numCols;return`${Array.from({length:t*2+1},(a,f)=>f===1?"    ":f%2===0?"+":"----").join("")}\r
`})),buildVerticalRow:(c,t,a)=>e.pipe(e.Effect.succeed(c),e.Effect.map(f=>{let n=[];return f.forEach((p,R)=>{n=[...n,R===t?` ${a} `:"    "],n=[...n,p?" ":"|"]}),n})),buildHorizRow:c=>e.pipe(e.Effect.succeed(c),e.Effect.map(t=>{let a=[];return a=[...a,`\r
+`],t.forEach((f,n)=>{a=[...a,f?"    ":"----"],a=[...a,"+"]}),a=[...a,`\r
`],a}))};class o extends e.Context.Tag("BuilderMaze")(){static Live=o.of(I)}const X=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("newX",t=>e.Effect.succeed(t.dx+t.currentX)),e.Effect.bind("newY",t=>e.Effect.succeed(t.dy+t.currentY)),e.Effect.bind("condition",({newX:t,newY:a})=>e.Effect.succeed(t<0||a<0||t>=c.maze.numRows||a>=c.maze.numCols)),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new s("Out of bounds")):e.Effect.succeed(!1))),J=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===0&&t.dy===1&&t.currentY<t.maze.numCols-1&&!t.maze.grid[t.currentX].vertical[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new s("Wall to the right")):e.Effect.succeed(!1))),$=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===1&&t.dy===0&&t.currentX<t.maze.numRows-1&&!t.maze.grid[t.currentX].horizontal[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new s("Wall below")):e.Effect.succeed(!1))),U=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===0&&t.dy===-1&&t.currentY>0&&!t.maze.grid[t.currentX].vertical[t.currentY-1])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new s("Wall to the left")):e.Effect.succeed(!1))),F=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("condition",t=>e.Effect.succeed(t.dx===-1&&t.dy===0&&t.currentX>0&&!t.maze.grid[t.currentX-1].horizontal[t.currentY])),e.Effect.flatMap(({condition:t})=>t?e.Effect.fail(new s("Wall above")):e.Effect.succeed(!1))),V=c=>e.pipe(e.Effect.succeed(c),e.Effect.map(t=>({dx:t.playerMoves.x,dy:t.playerMoves.y,currentX:t.currentPosition.x,currentY:t.currentPosition.y,maze:t.maze})),e.Effect.map(t=>e.Schema.decodeUnknownSync(O)(t))),j=c=>e.pipe(V(c),e.Effect.flatMap(t=>X(t).pipe(e.Effect.andThen(()=>F(t)),e.Effect.andThen(()=>$(t)),e.Effect.andThen(()=>U(t)),e.Effect.andThen(()=>J(t)))),e.Effect.flatMap(()=>e.Effect.succeed({x:c.currentPosition.x+c.playerMoves.x,y:c.currentPosition.y+c.playerMoves.y})),e.Effect.catchTag("GamePlayError",t=>e.Effect.fail(t))),Z=c=>e.Effect.sync(()=>e.pipe(e.Effect.succeed(c),e.Effect.bindTo("gameState"),e.Effect.bind("randomDirection",()=>e.Effect.succeed(y[Math.floor(Math.random()*y.length)])),e.Effect.bind("state",({randomDirection:t,gameState:a})=>e.Effect.succeed({playerMoves:t,...a})),e.Effect.tap(({state:t})=>b(t)),e.Effect.flatMap(({state:t})=>K(t)))),K=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("position",()=>e.Ref.get(c.currentPosition)),e.Effect.bind("mazeState",()=>e.Ref.get(c.maze)),e.Effect.map(({position:t,mazeState:{maze:a}})=>t.x===a.numRows-1&&t.y===a.numCols-1?e.Effect.succeed("Game Over"):e.Effect.fail(new s("Game not over"))),e.Effect.flatMap(t=>t),e.Effect.catchTag("GamePlayError",t=>e.Effect.succeed(t))),Q=c=>e.Effect.repeat(Z(c),{until:t=>t.pipe(e.Effect.map(a=>a==="Game Over")),schedule:e.Schedule.addDelay(e.Schedule.forever,()=>"50 millis")}),ee=({x:c,y:t},a)=>c===a?t:-1,te=({vertical:c,horizontal:t},a)=>e.pipe(e.Effect.all({builderMaze:o,currentPosition:d,mazeData:r}),e.Effect.bind("position",({currentPosition:f})=>e.Ref.get(f)),e.Effect.bind("maze",({mazeData:f})=>e.Ref.get(f)),e.Effect.flatMap(({builderMaze:f,position:n,maze:p})=>e.Effect.all({verticalRow:f.buildVerticalRow(c,ee(n,a),p.player),horizontalRow:f.buildHorizRow(t)})),e.Effect.map(({verticalRow:f,horizontalRow:n})=>["|",...f,...n])),ce=e.pipe(e.Effect.all({mazeData:r,builder:o}),e.Effect.bind("state",({mazeData:c})=>e.Ref.get(c)),e.Effect.bind("topWall",({builder:c})=>c.buildTopWall),e.Effect.bind("mazeLayout",({state:{maze:c}})=>e.pipe(c.grid,e.Effect.forEach(te),e.Effect.map(t=>t.flat()))),e.Effect.map(({topWall:c,mazeLayout:t})=>[...c,...t]),e.Effect.provideService(o,o.Live)),b=({currentPosition:c,maze:t,playerMoves:a})=>e.pipe(e.Effect.all({currPostion:e.Ref.get(c),mazeVal:e.Ref.get(t)}),e.Effect.flatMap(({currPostion:f,mazeVal:n})=>j({currentPosition:f,maze:n.maze,playerMoves:a})),e.Effect.tap(f=>e.pipe(e.Ref.update(c,()=>f),e.Effect.zip(v({currentPosition:c,maze:t})),e.Effect.zip(ae({currentPosition:c,maze:t})))),e.Effect.catchTag("GamePlayError",e.Effect.succeed),e.Effect.runPromise),ae=c=>e.pipe(e.Effect.succeed(c),e.Effect.bind("position",()=>e.Ref.get(c.currentPosition)),e.Effect.bind("mazeState",()=>e.Ref.get(c.maze)),e.Effect.tap(({position:t,mazeState:{maze:a}})=>{t.x===a.numRows-1&&t.y===a.numCols-1&&(console.log("Congratulations 🎉 🎉 🎉! You have reached the end of the maze."),process.exit())})),fe=c=>e.pipe(e.Effect.sync(()=>{x.emitKeypressEvents(process.stdin),process.stdin.setRawMode(!0),process.stdin.resume()}),e.Effect.flatMap(()=>e.Effect.async(()=>{process.stdin.on("keypress",(t,a)=>{let f={x:0,y:0};if(t==="")process.exit();else{switch(a.name){case"up":f={x:-1,y:0};break;case"down":f={x:1,y:0};break;case"left":f={x:0,y:-1};break;case"right":f={x:0,y:1};break}b({playerMoves:f,...c})}})}))),v=c=>e.pipe(ce,e.Effect.tap(()=>Y()),e.Effect.tap(t=>console.log(t.join(""))),e.Effect.provideServiceEffect(r,e.Effect.succeed(c.maze)),e.Effect.provideServiceEffect(d,e.Effect.succeed(c.currentPosition))),ne=e.Effect.gen(function*(c){const t=yield*c(r),a=yield*c(d);(yield*e.Ref.get(t)).gameMode==="Freedom"?Q({maze:t,currentPosition:a}).pipe(e.Effect.runPromise):fe({maze:t,currentPosition:a}).pipe(e.Effect.runPromise)}),ie=e.pipe(e.Effect.all({maze:r,currentPosition:d}),e.Effect.tap(({currentPosition:c,maze:t})=>v({maze:t,currentPosition:c})),e.Effect.tap(()=>ne),e.Effect.provideServiceEffect(d,e.Ref.make({x:0,y:0}))),g=e.Effect.gen(function*(){const c=yield*B;return(yield*i.HttpClient.HttpClient).pipe(i.HttpClient.mapRequest(e.flow(i.HttpClientRequest.acceptJson,i.HttpClientRequest.prependUrl(c))))}),S=(c,t)=>e.Effect.gen(function*(){return console.log(q),yield*i.HttpClientResponse.matchStatus({200:f=>i.HttpClientResponse.schemaBodyJson(t)(f),orElse:f=>e.Effect.fail(f)})(c)});class u extends e.Effect.Service()("MazeAPI",{dependencies:[],effect:e.Effect.gen(function*(){return{getMaze:t=>e.pipe(g,e.Effect.flatMap(a=>a.get(w.replace(":maze_id",t))),e.Effect.flatMap(a=>S(a,l)),e.Effect.provide(i.FetchHttpClient.layer)),getDataMaze:()=>e.pipe(g,e.Effect.flatMap(t=>t.get(`${C}`)),e.Effect.flatMap(t=>S(t,H)),e.Effect.provide(i.FetchHttpClient.layer))}})}){}const re=e.Effect.gen(function*(){const c=yield*u,t=yield*c.getDataMaze(),a=yield*e.Effect.promise(()=>E.select({message:"Choose your labyrinth tier:",choices:t.map(n=>({name:n.mazeName,value:n.maze_id,description:n.description}))}));return yield*c.getMaze(a)}).pipe(e.Effect.catchAll(c=>(console.error("Error fetching maze:",c),e.Effect.succeed(c))),e.Effect.provide(u.Default)),oe=e.pipe(e.Effect.promise(()=>E.select({message:"Select your player character:",choices:W})),e.Effect.map(c=>c)),se=e.pipe(e.Effect.promise(()=>E.select({message:"Pick your gameplay mode:",choices:["Freedom","Guided"]})),e.Effect.map(c=>c));class z extends e.Effect.Service()("MazeMenu",{dependencies:[u.Default],effect:e.pipe(e.Effect.all({player:oe,maze:re,gameMode:se}),e.Effect.map(({player:t,maze:a,gameMode:f})=>e.Schema.decodeUnknownSync(_)({player:t,maze:a,gameMode:f})),e.Effect.tap(t=>e.Effect.gen(function*(){const a=yield*r;yield*e.Ref.set(a,t)})))}){}e.pipe(z,e.Effect.flatMap(()=>ie),e.Effect.provide(z.Default),e.Effect.provideServiceEffect(r,e.Ref.make(L)),e.Effect.runPromise);
